#include <iostream>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <set>
#include <numeric>


using namespace std;
//СУММА ЭЛЕМЕНТОВ
//Все уникальные элементы в массиве имеют частоту 2, кроме одного элемента.

//Храните все уникальные элементы в наборе.
//Сложите элементы набора и умножьте на 2 (SUM_1).
//Добавьте все элементы массива(ARRAY_SUM).
//Возврат(SUM_1 - ARRAY_SUM) .
//Почему это работает ? ?
//ARRAY_SUM = 2 * (a1 + a2 + a3... + ak) + a(k + 1)
//SUM_1 = 2 * (a1 + a2 + a3 + .... + ak + a(k + 1))

//a(x) представляет x - й уникальный элемент в массиве.
//a(k + 1) представляет элемент с частотой = 1.


class Solution {
public:
    static int singleNumber(vector<int>& nums) {        

        // С доп памятью
        /*auto sum_vec = std::accumulate(begin(nums)
            , end(nums)
            , 0
            , [](int value, const vector<int>::value_type& p)
            { return value + p; }
        );

        unordered_set<int> u_s;

        for (auto el : nums) {

            u_s.insert(el);
        }

        auto sum_non_dupl = std::accumulate(begin(u_s)
            , end(u_s)
            , 0
            , [](int value, const set<int>::value_type& p)
            { return value + p; }
        );

        int result = 2 * sum_non_dupl -sum_vec;

        return result;*/

        //на основе XOR

       //ИСПОЛЬЗОВАНИЕ ПОБИТОВОГО ОПЕРАТОРА XOR(ИСПОЛЬЗОВАНИЕ ПОСТОЯННОГО ПРОБЕЛА)
       //     Чтобы использовать этот подход, вам сначала нужно понять побитовый оператор XOR.
       //     Большинство из нас, имеющих образование в области физики(уровень средней школы), знают о ЛОГИЧЕСКИХ ВРАТАХ.
       //     Одним из таких ворот является XOR Gate :
       // В соответствии с этим вентилем выход истинен, только если оба входа противоположны.
       //     То есть,
       //     А Б Я
       //     0 0 0
       //     0 1 1
       //     1 0 1
       //     1 1 0
       //
       //     Мы применяем расширенную версию этого вентиля в нашем побитовом операторе XOR.
       //     Если мы делаем «a ^ b», это означает, что мы применяем вентиль XOR к 2 числам побитовым образом(к каждому из соответствующих битов чисел).
       //     Точно так же, если мы наблюдаем,
       //
       //     А^ А = 0
       //     А ^ Б ^ А = Б
       //     (A ^ A ^ B) = (B ^ A ^ A) = (A ^ B ^ A) = B Это показывает, что положение не имеет значения.
       //     Точно так же, если мы видим, a ^ a ^ a......... (четное время) = 0 и a ^ a ^ a........(нечетное время) = a
       //     Google Это для более подробной информации.
       //
       //     Применим приведенные выше наблюдения :
       //
       // Пройдитесь по массиву и выполните побитовое XOR каждого элемента.
       //     Вернуть значение.
       //     Почему это работает ? ?
       //     Потому что элементы с частотой = 2 дадут 0. И тогда единственный элемент с частотой = 1 сгенерирует ответ.

        int ans = 0;
        for (auto x : nums) {
            ans ^= x;
        }
        return ans;

    }
};

int main()
{

    vector<int> vec = { 1,2,2,3,3 };

    Solution::singleNumber(vec);

    if (Solution::singleNumber(vec) == 1) {
        std::cout << "Test comlete" << std::endl;
    }
    else {

        std::cout << "Test denied" << std::endl;
    }
    
}
